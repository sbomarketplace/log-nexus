import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { StructuredIncident } from '@/types/export';

export const generatePDF = async (incident: StructuredIncident): Promise<Blob> => {
  const doc = new jsPDF();
  const margin = 20;
  const pageWidth = doc.internal.pageSize.width;
  const contentWidth = pageWidth - (margin * 2);
  
  let yPosition = margin;

  // Helper function to add text with word wrapping
  const addWrappedText = (text: string, x: number, y: number, maxWidth: number, fontSize = 10): number => {
    doc.setFontSize(fontSize);
    const lines = doc.splitTextToSize(text, maxWidth);
    doc.text(lines, x, y);
    return y + (lines.length * (fontSize * 0.35));
  };

  // Header
  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.text('INCIDENT REPORT', margin, yPosition);
  yPosition += 15;

  // Date and Category chips
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setFillColor(240, 240, 240);
  doc.roundedRect(margin, yPosition, 50, 8, 2, 2, 'F');
  doc.text(incident.dateISO, margin + 2, yPosition + 5);
  
  doc.setFillColor(59, 130, 246);
  doc.roundedRect(margin + 55, yPosition, 60, 8, 2, 2, 'F');
  doc.setTextColor(255, 255, 255);
  doc.text(incident.category, margin + 57, yPosition + 5);
  doc.setTextColor(0, 0, 0);
  
  yPosition += 20;

  // Title
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  yPosition = addWrappedText(incident.title, margin, yPosition, contentWidth, 14);
  yPosition += 10;

  // Sections
  const sections = [
    { title: 'WHAT HAPPENED', content: incident.what },
    { title: 'WHERE', content: incident.where },
    { title: 'WHEN', content: incident.when },
    { title: 'WHO WAS INVOLVED', content: incident.who.join(', ') },
    { title: 'WITNESSES', content: incident.witnesses.join(', ') },
    { title: 'SUMMARY', content: incident.summary },
  ];

  if (incident.requests) {
    sections.push({ title: 'REQUESTS & RESPONSES', content: incident.requests });
  }
  
  if (incident.policy) {
    sections.push({ title: 'POLICY NOTES', content: incident.policy });
  }
  
  if (incident.evidence) {
    sections.push({ title: 'EVIDENCE', content: incident.evidence });
  }

  for (const section of sections) {
    // Check if we need a new page
    if (yPosition > doc.internal.pageSize.height - 40) {
      doc.addPage();
      yPosition = margin;
    }

    // Section title
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text(section.title, margin, yPosition);
    yPosition += 8;

    // Section content
    doc.setFont('helvetica', 'normal');
    yPosition = addWrappedText(section.content, margin, yPosition, contentWidth, 10);
    yPosition += 8;
  }

  // Timeline table if present
  if (incident.timeline.length > 0) {
    if (yPosition > doc.internal.pageSize.height - 60) {
      doc.addPage();
      yPosition = margin;
    }

    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('TIMELINE', margin, yPosition);
    yPosition += 10;

    const timelineData = incident.timeline.map(item => [
      item.time || '',
      item.note
    ]);

    autoTable(doc, {
      startY: yPosition,
      head: [['Time', 'Event']],
      body: timelineData,
      margin: { left: margin, right: margin },
      styles: { fontSize: 9 },
      headStyles: { fillColor: [59, 130, 246] },
      columnStyles: {
        0: { cellWidth: 30 },
        1: { cellWidth: contentWidth - 30 }
      }
    });

    yPosition = (doc as any).lastAutoTable.finalY + 10;
  }

  // Footer
  if (yPosition > doc.internal.pageSize.height - 30) {
    doc.addPage();
    yPosition = margin;
  }

  doc.setFontSize(8);
  doc.setFont('helvetica', 'italic');
  doc.setTextColor(128, 128, 128);
  
  const footerText = [
    `Created: ${new Date(incident.createdAtISO).toLocaleString()}`,
    incident.updatedAtISO ? `Updated: ${new Date(incident.updatedAtISO).toLocaleString()}` : '',
    `Generated by ClearCase on ${new Date().toLocaleString()}`
  ].filter(Boolean).join(' | ');
  
  doc.text(footerText, margin, yPosition);

  return doc.output('blob');
};